#!/usr/local/bin/ruby1.9 -w
# 
#  nosyd
#  homework 6
#  
#  Created by Glen Cuthbertson on 2009-11-06.
#  Copyright 2009 GLENC.COM. All rights reserved.
# 
exit!(0) if fork
require 'yaml'

#Dir.chdir("/")
File::umask(0)

def go
  setConstants
  redirectIo
  defineSigs
  daemon_log "******** Strating! (#{$$}) ********"
  daemon_log "working directory: #{Dir.getwd}"
  readConf
end

def setConstants
  $configFile = File.basename($0)+'.conf'
  $configHash = {}
  $run = true
  $debug = false
  $logName = File.basename($0)+'.log'
  $logFile = File.new($logName,"a")
end

def redirectIo
  STDIN.reopen("/dev/null")
  STDOUT.reopen("/dev/null","w")
  STDERR.reopen("/dev/null","w")
end

def defineSigs
  Signal.trap("INT")  {clearLog}
  Signal.trap("HUP")  {readConf true}
  Signal.trap("USR1") {writeSecret}
  Signal.trap("QUIT") {die}
end

def daemon_log(str)
  $logFile.reopen($logName,"a")
  msg = "[#{Time.now.strftime("%m/%d/%Y-%H:%M:%S")} : #{$$}] #{str}"
  $debug ? (puts msg) : ($logFile.puts msg)
  $logFile.close
end

def clearLog
  begin
    File.truncate($logName,0)
    daemon_log "SIGINT: logcleared"    
  rescue Exception => e
    deamon_log e
  end
end

def readConf (sig=false)
  begin
    config = File.open($configFile,"r"){|f| $configHash = YAML.load(f)}
    daemon_log "SIGHUP: re-reading conf file" if sig
    daemon_log "******** Read Config file: #{$configFile} to Config Hash"
    daemon_log "******** Config hash contains:"
    $configHash.each {|k,v| daemon_log "#{k}:#{v}"}
  rescue
    daemon_log "cannot file config file: #{configFile}"
    abort
  end
end

def writeSecret
  daemon_log "SIGUSR1: the secret code is: #{$configHash['secret_code']}"
end

def die
  daemon_log "SIGQUIT: quitting pid: #{$$}"
  $run = false
  exit(0)
end

go # done setting up daemon, now to tasks

def doTasks
  while $run do
    begin
      daemon_log "******** I'M AWAKE!!!!!!!!!!!!!!!!!!!!!"
      findJnk
      checkWorldWrite
      checkSize
      daemon_log "...going back to sleep for #{$configHash['sleep_time']} seconds"
      sleep $configHash['sleep_time'].to_i
    rescue Exception => e
      daemon_log e
      die
    end
  end
end

def findJnk
  junkFiles = File.join("**", "*#{$configHash['junk_file_ext']}")
  arr = Dir.glob(junkFiles)
  daemon_log "******** looking for junk files"
  if arr.length > 0
    arr.each {|i| deleteFile i}
  else
    daemon_log "=> no junk files found"
  end
end

def deleteFile (path)
  daemon_log "=> deleting: #{path}"
  File.delete(path)
end

def checkWorldWrite
  daemon_log "******** looking for world writable files"
  files = File.join("**","*")
  arr = Dir.glob(files)
  arr.each do |file|
    daemon_log "=> #{file} :is writable by others" if File.world_writable?(file).to_s.empty? != true
  end
end

def checkSize
  daemon_log "******** looking for file size matches:"
  files = File.join("**","*")
  maxSizeArr = $configHash['max_file_size'].gsub(/\s/, '').scan(/^\d*|\D/)
  maxSize = maxSizeArr.length > 0 ? maxSizeArr[0].to_i : false
  maxSizeDenom = maxSizeArr.length > 1 ?  maxSizeArr[1] : false
  if maxSize
    denom = case maxSizeDenom
      when "k","K" then [1000,'kb']
      when "m","M" then [1000000,'mb']
      when "g","G" then [1000000000,'gb']
      else [1,'b']
    end
    daemon_log "denomination is #{denom}" if $debug == true
    daemon_log "maxSize value is #{maxSize}" if $debug == true
    maxBytes = maxSize*denom[0]
    daemon_log "actual maxBytes is #{maxBytes}" if $debug == true
    daemon_log "files of zero bytes or >= #{maxSize}#{denom[1]}:"
  end
  arr = Dir.glob(files)
  arr.each do |file|
    daemon_log "=> #{file} :is zero bytes" if File.size(file) == 0
    if maxSize
      daemon_log "=> #{file}(#{(File.size(file)/denom[0]).round}#{denom[1]}) >= #{$configHash['max_file_size']}" if File.size(file).to_i >= maxBytes.to_i
    end
  end  
end

doTasks